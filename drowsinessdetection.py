# -*- coding: utf-8 -*-
"""DrowsinessDetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sOkZbJlbWJauUOy4EYx-9FjEuWlxrvww
"""

import cv2
import numpy as np
import dlib
from imutils import face_utils
from google.colab.patches import cv2_imshow

# Define the threshold for detecting drowsiness
DROWSINESS_THRESHOLD = 10
DROWSINESS_FRAMES = 5

# Function to calculate distance between two points
def calculate_distance(a, b):
    x1, y1 = a
    x2, y2 = b
    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

# Function to detect drowsiness
def detect_drowsiness(dlist):
    return sum(dlist) >= DROWSINESS_FRAMES

# Define the function to capture a photo
def take_photo(quality=0.8):
    from IPython.display import display, Javascript
    from google.colab.output import eval_js
    from base64 import b64decode

    js = Javascript('''
        async function takePhoto(quality) {
            const div = document.createElement('div');
            const capture = document.createElement('button');
            capture.textContent = 'Capture';
            div.appendChild(capture);

            const video = document.createElement('video');
            video.style.display = 'block';
            const stream = await navigator.mediaDevices.getUserMedia({video: true});

            document.body.appendChild(div);
            div.appendChild(video);
            video.srcObject = stream;
            await video.play();

            // Resize the output to fit the video element.
            google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

            // Wait for Capture to be clicked.
            await new Promise((resolve) => capture.onclick = resolve);

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            stream.getVideoTracks()[0].stop();
            div.remove();
            return canvas.toDataURL('image/jpeg', quality);
        }
    ''')
    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    return binary

import urllib.request

# URL of the shape predictor file
shape_predictor_url = "http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2"
# Local file path where the shape predictor file will be saved
shape_predictor_file = "shape_predictor_68_face_landmarks.dat.bz2"

# Download the shape predictor file
print("Downloading shape predictor file...")
urllib.request.urlretrieve(shape_predictor_url, shape_predictor_file)
print("Shape predictor file downloaded successfully!")

# Define the main function
def main():
    # Initialize the face detector and shape predictor
    detector = dlib.get_frontal_face_detector()
    predictor = dlib.shape_predictor("/content/shape_predictor_68_face_landmarks.dat")

    dlist = []

    while True:
        frame_data = take_photo()  # Call the take_photo function to capture a frame
        nparr = np.frombuffer(frame_data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        rects = detector(gray, 0)

        for (i, rect) in enumerate(rects):
            shape = predictor(gray, rect)
            shape = face_utils.shape_to_np(shape)

            le_38 = shape[37]
            le_39 = shape[38]
            le_41 = shape[40]
            le_42 = shape[41]

            re_44 = shape[43]
            re_45 = shape[44]
            re_47 = shape[46]
            re_48 = shape[47]

            # Calculate the average distance between facial landmarks
            avg_distance = (calculate_distance(le_38, le_42) + calculate_distance(le_39, le_41) +
                            calculate_distance(re_44, re_48) + calculate_distance(re_45, re_47)) / 4

            # Append the average distance to the list
            dlist.append(avg_distance)

            # Check if the length of dlist exceeds the threshold for consecutive frames
            if len(dlist) > DROWSINESS_FRAMES:
                dlist.pop(0)

            # Check if drowsiness is detected based on the average distance and threshold
            if detect_drowsiness(dlist):
                cv2.putText(frame, "Drowsiness Detected", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
            else:
                cv2.putText(frame, "No Drowsiness", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
        print("Output")
        cv2_imshow(frame)

        if cv2.waitKey(1) & 0xFF == 27:
            break

    cv2.destroyAllWindows()